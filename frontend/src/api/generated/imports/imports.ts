/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * Initiative API
 * OpenAPI spec version: 0.31.1
 */
import { useMutation } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";

import type {
  HTTPValidationError,
  ImportFromTicktickApiV1ImportsTicktickPostHeaders,
  ImportFromTodoistApiV1ImportsTodoistPostHeaders,
  ImportFromVikunjaApiV1ImportsVikunjaPostHeaders,
  ImportResult,
  TickTickImportRequest,
  TickTickParseResult,
  TodoistImportRequest,
  TodoistParseResult,
  VikunjaImportRequest,
  VikunjaParseResult,
} from "../initiativeAPI.schemas";

import { apiMutator } from "../../mutator";
import type { ErrorType, BodyType } from "../../mutator";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Parse a Todoist CSV export and return detected sections and task count.

This is a preview endpoint to help users map sections before importing.
 * @summary Parse Todoist Csv
 */
export type parseTodoistCsvApiV1ImportsTodoistParsePostResponse200 = {
  data: TodoistParseResult;
  status: 200;
};

export type parseTodoistCsvApiV1ImportsTodoistParsePostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type parseTodoistCsvApiV1ImportsTodoistParsePostResponseSuccess =
  parseTodoistCsvApiV1ImportsTodoistParsePostResponse200 & {
    headers: Headers;
  };
export type parseTodoistCsvApiV1ImportsTodoistParsePostResponseError =
  parseTodoistCsvApiV1ImportsTodoistParsePostResponse422 & {
    headers: Headers;
  };

export type parseTodoistCsvApiV1ImportsTodoistParsePostResponse =
  | parseTodoistCsvApiV1ImportsTodoistParsePostResponseSuccess
  | parseTodoistCsvApiV1ImportsTodoistParsePostResponseError;

export const getParseTodoistCsvApiV1ImportsTodoistParsePostUrl = () => {
  return `/api/v1/imports/todoist/parse`;
};

export const parseTodoistCsvApiV1ImportsTodoistParsePost = async (
  parseTodoistCsvApiV1ImportsTodoistParsePostBody: string,
  options?: RequestInit
): Promise<parseTodoistCsvApiV1ImportsTodoistParsePostResponse> => {
  return apiMutator<parseTodoistCsvApiV1ImportsTodoistParsePostResponse>(
    getParseTodoistCsvApiV1ImportsTodoistParsePostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "text/plain", ...options?.headers },
      body: parseTodoistCsvApiV1ImportsTodoistParsePostBody,
    }
  );
};

export const getParseTodoistCsvApiV1ImportsTodoistParsePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof parseTodoistCsvApiV1ImportsTodoistParsePost>>,
    TError,
    { data: BodyType<string> },
    TContext
  >;
  request?: SecondParameter<typeof apiMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof parseTodoistCsvApiV1ImportsTodoistParsePost>>,
  TError,
  { data: BodyType<string> },
  TContext
> => {
  const mutationKey = ["parseTodoistCsvApiV1ImportsTodoistParsePost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof parseTodoistCsvApiV1ImportsTodoistParsePost>>,
    { data: BodyType<string> }
  > = (props) => {
    const { data } = props ?? {};

    return parseTodoistCsvApiV1ImportsTodoistParsePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ParseTodoistCsvApiV1ImportsTodoistParsePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof parseTodoistCsvApiV1ImportsTodoistParsePost>>
>;
export type ParseTodoistCsvApiV1ImportsTodoistParsePostMutationBody = BodyType<string>;
export type ParseTodoistCsvApiV1ImportsTodoistParsePostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Parse Todoist Csv
 */
export const useParseTodoistCsvApiV1ImportsTodoistParsePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof parseTodoistCsvApiV1ImportsTodoistParsePost>>,
      TError,
      { data: BodyType<string> },
      TContext
    >;
    request?: SecondParameter<typeof apiMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof parseTodoistCsvApiV1ImportsTodoistParsePost>>,
  TError,
  { data: BodyType<string> },
  TContext
> => {
  return useMutation(
    getParseTodoistCsvApiV1ImportsTodoistParsePostMutationOptions(options),
    queryClient
  );
};
/**
 * Import tasks from a Todoist CSV export into a project.

The section_mapping maps Todoist section names to task_status_id values
in the target project.
 * @summary Import From Todoist
 */
export type importFromTodoistApiV1ImportsTodoistPostResponse200 = {
  data: ImportResult;
  status: 200;
};

export type importFromTodoistApiV1ImportsTodoistPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type importFromTodoistApiV1ImportsTodoistPostResponseSuccess =
  importFromTodoistApiV1ImportsTodoistPostResponse200 & {
    headers: Headers;
  };
export type importFromTodoistApiV1ImportsTodoistPostResponseError =
  importFromTodoistApiV1ImportsTodoistPostResponse422 & {
    headers: Headers;
  };

export type importFromTodoistApiV1ImportsTodoistPostResponse =
  | importFromTodoistApiV1ImportsTodoistPostResponseSuccess
  | importFromTodoistApiV1ImportsTodoistPostResponseError;

export const getImportFromTodoistApiV1ImportsTodoistPostUrl = () => {
  return `/api/v1/imports/todoist`;
};

export const importFromTodoistApiV1ImportsTodoistPost = async (
  todoistImportRequest: TodoistImportRequest,
  headers?: ImportFromTodoistApiV1ImportsTodoistPostHeaders,
  options?: RequestInit
): Promise<importFromTodoistApiV1ImportsTodoistPostResponse> => {
  return apiMutator<importFromTodoistApiV1ImportsTodoistPostResponse>(
    getImportFromTodoistApiV1ImportsTodoistPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...headers, ...options?.headers },
      body: JSON.stringify(todoistImportRequest),
    }
  );
};

export const getImportFromTodoistApiV1ImportsTodoistPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importFromTodoistApiV1ImportsTodoistPost>>,
    TError,
    {
      data: BodyType<TodoistImportRequest>;
      headers?: ImportFromTodoistApiV1ImportsTodoistPostHeaders;
    },
    TContext
  >;
  request?: SecondParameter<typeof apiMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof importFromTodoistApiV1ImportsTodoistPost>>,
  TError,
  {
    data: BodyType<TodoistImportRequest>;
    headers?: ImportFromTodoistApiV1ImportsTodoistPostHeaders;
  },
  TContext
> => {
  const mutationKey = ["importFromTodoistApiV1ImportsTodoistPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importFromTodoistApiV1ImportsTodoistPost>>,
    {
      data: BodyType<TodoistImportRequest>;
      headers?: ImportFromTodoistApiV1ImportsTodoistPostHeaders;
    }
  > = (props) => {
    const { data, headers } = props ?? {};

    return importFromTodoistApiV1ImportsTodoistPost(data, headers, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportFromTodoistApiV1ImportsTodoistPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importFromTodoistApiV1ImportsTodoistPost>>
>;
export type ImportFromTodoistApiV1ImportsTodoistPostMutationBody = BodyType<TodoistImportRequest>;
export type ImportFromTodoistApiV1ImportsTodoistPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Import From Todoist
 */
export const useImportFromTodoistApiV1ImportsTodoistPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importFromTodoistApiV1ImportsTodoistPost>>,
      TError,
      {
        data: BodyType<TodoistImportRequest>;
        headers?: ImportFromTodoistApiV1ImportsTodoistPostHeaders;
      },
      TContext
    >;
    request?: SecondParameter<typeof apiMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importFromTodoistApiV1ImportsTodoistPost>>,
  TError,
  {
    data: BodyType<TodoistImportRequest>;
    headers?: ImportFromTodoistApiV1ImportsTodoistPostHeaders;
  },
  TContext
> => {
  return useMutation(
    getImportFromTodoistApiV1ImportsTodoistPostMutationOptions(options),
    queryClient
  );
};
/**
 * Parse a Vikunja JSON export and return detected projects with buckets.

This is a preview endpoint to help users select a project and map buckets.
 * @summary Parse Vikunja Json
 */
export type parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse200 = {
  data: VikunjaParseResult;
  status: 200;
};

export type parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type parseVikunjaJsonApiV1ImportsVikunjaParsePostResponseSuccess =
  parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse200 & {
    headers: Headers;
  };
export type parseVikunjaJsonApiV1ImportsVikunjaParsePostResponseError =
  parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse422 & {
    headers: Headers;
  };

export type parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse =
  | parseVikunjaJsonApiV1ImportsVikunjaParsePostResponseSuccess
  | parseVikunjaJsonApiV1ImportsVikunjaParsePostResponseError;

export const getParseVikunjaJsonApiV1ImportsVikunjaParsePostUrl = () => {
  return `/api/v1/imports/vikunja/parse`;
};

export const parseVikunjaJsonApiV1ImportsVikunjaParsePost = async (
  parseVikunjaJsonApiV1ImportsVikunjaParsePostBody: string,
  options?: RequestInit
): Promise<parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse> => {
  return apiMutator<parseVikunjaJsonApiV1ImportsVikunjaParsePostResponse>(
    getParseVikunjaJsonApiV1ImportsVikunjaParsePostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "text/plain", ...options?.headers },
      body: parseVikunjaJsonApiV1ImportsVikunjaParsePostBody,
    }
  );
};

export const getParseVikunjaJsonApiV1ImportsVikunjaParsePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof parseVikunjaJsonApiV1ImportsVikunjaParsePost>>,
    TError,
    { data: BodyType<string> },
    TContext
  >;
  request?: SecondParameter<typeof apiMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof parseVikunjaJsonApiV1ImportsVikunjaParsePost>>,
  TError,
  { data: BodyType<string> },
  TContext
> => {
  const mutationKey = ["parseVikunjaJsonApiV1ImportsVikunjaParsePost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof parseVikunjaJsonApiV1ImportsVikunjaParsePost>>,
    { data: BodyType<string> }
  > = (props) => {
    const { data } = props ?? {};

    return parseVikunjaJsonApiV1ImportsVikunjaParsePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ParseVikunjaJsonApiV1ImportsVikunjaParsePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof parseVikunjaJsonApiV1ImportsVikunjaParsePost>>
>;
export type ParseVikunjaJsonApiV1ImportsVikunjaParsePostMutationBody = BodyType<string>;
export type ParseVikunjaJsonApiV1ImportsVikunjaParsePostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Parse Vikunja Json
 */
export const useParseVikunjaJsonApiV1ImportsVikunjaParsePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof parseVikunjaJsonApiV1ImportsVikunjaParsePost>>,
      TError,
      { data: BodyType<string> },
      TContext
    >;
    request?: SecondParameter<typeof apiMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof parseVikunjaJsonApiV1ImportsVikunjaParsePost>>,
  TError,
  { data: BodyType<string> },
  TContext
> => {
  return useMutation(
    getParseVikunjaJsonApiV1ImportsVikunjaParsePostMutationOptions(options),
    queryClient
  );
};
/**
 * Import tasks from a Vikunja JSON export into a project.

The bucket_mapping maps Vikunja bucket IDs to task_status_id values
in the target project.
 * @summary Import From Vikunja
 */
export type importFromVikunjaApiV1ImportsVikunjaPostResponse200 = {
  data: ImportResult;
  status: 200;
};

export type importFromVikunjaApiV1ImportsVikunjaPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type importFromVikunjaApiV1ImportsVikunjaPostResponseSuccess =
  importFromVikunjaApiV1ImportsVikunjaPostResponse200 & {
    headers: Headers;
  };
export type importFromVikunjaApiV1ImportsVikunjaPostResponseError =
  importFromVikunjaApiV1ImportsVikunjaPostResponse422 & {
    headers: Headers;
  };

export type importFromVikunjaApiV1ImportsVikunjaPostResponse =
  | importFromVikunjaApiV1ImportsVikunjaPostResponseSuccess
  | importFromVikunjaApiV1ImportsVikunjaPostResponseError;

export const getImportFromVikunjaApiV1ImportsVikunjaPostUrl = () => {
  return `/api/v1/imports/vikunja`;
};

export const importFromVikunjaApiV1ImportsVikunjaPost = async (
  vikunjaImportRequest: VikunjaImportRequest,
  headers?: ImportFromVikunjaApiV1ImportsVikunjaPostHeaders,
  options?: RequestInit
): Promise<importFromVikunjaApiV1ImportsVikunjaPostResponse> => {
  return apiMutator<importFromVikunjaApiV1ImportsVikunjaPostResponse>(
    getImportFromVikunjaApiV1ImportsVikunjaPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...headers, ...options?.headers },
      body: JSON.stringify(vikunjaImportRequest),
    }
  );
};

export const getImportFromVikunjaApiV1ImportsVikunjaPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importFromVikunjaApiV1ImportsVikunjaPost>>,
    TError,
    {
      data: BodyType<VikunjaImportRequest>;
      headers?: ImportFromVikunjaApiV1ImportsVikunjaPostHeaders;
    },
    TContext
  >;
  request?: SecondParameter<typeof apiMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof importFromVikunjaApiV1ImportsVikunjaPost>>,
  TError,
  {
    data: BodyType<VikunjaImportRequest>;
    headers?: ImportFromVikunjaApiV1ImportsVikunjaPostHeaders;
  },
  TContext
> => {
  const mutationKey = ["importFromVikunjaApiV1ImportsVikunjaPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importFromVikunjaApiV1ImportsVikunjaPost>>,
    {
      data: BodyType<VikunjaImportRequest>;
      headers?: ImportFromVikunjaApiV1ImportsVikunjaPostHeaders;
    }
  > = (props) => {
    const { data, headers } = props ?? {};

    return importFromVikunjaApiV1ImportsVikunjaPost(data, headers, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportFromVikunjaApiV1ImportsVikunjaPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importFromVikunjaApiV1ImportsVikunjaPost>>
>;
export type ImportFromVikunjaApiV1ImportsVikunjaPostMutationBody = BodyType<VikunjaImportRequest>;
export type ImportFromVikunjaApiV1ImportsVikunjaPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Import From Vikunja
 */
export const useImportFromVikunjaApiV1ImportsVikunjaPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importFromVikunjaApiV1ImportsVikunjaPost>>,
      TError,
      {
        data: BodyType<VikunjaImportRequest>;
        headers?: ImportFromVikunjaApiV1ImportsVikunjaPostHeaders;
      },
      TContext
    >;
    request?: SecondParameter<typeof apiMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importFromVikunjaApiV1ImportsVikunjaPost>>,
  TError,
  {
    data: BodyType<VikunjaImportRequest>;
    headers?: ImportFromVikunjaApiV1ImportsVikunjaPostHeaders;
  },
  TContext
> => {
  return useMutation(
    getImportFromVikunjaApiV1ImportsVikunjaPostMutationOptions(options),
    queryClient
  );
};
/**
 * Parse a TickTick CSV export and return detected lists with columns.

This is a preview endpoint to help users select a list and map columns.
 * @summary Parse Ticktick Csv
 */
export type parseTicktickCsvApiV1ImportsTicktickParsePostResponse200 = {
  data: TickTickParseResult;
  status: 200;
};

export type parseTicktickCsvApiV1ImportsTicktickParsePostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type parseTicktickCsvApiV1ImportsTicktickParsePostResponseSuccess =
  parseTicktickCsvApiV1ImportsTicktickParsePostResponse200 & {
    headers: Headers;
  };
export type parseTicktickCsvApiV1ImportsTicktickParsePostResponseError =
  parseTicktickCsvApiV1ImportsTicktickParsePostResponse422 & {
    headers: Headers;
  };

export type parseTicktickCsvApiV1ImportsTicktickParsePostResponse =
  | parseTicktickCsvApiV1ImportsTicktickParsePostResponseSuccess
  | parseTicktickCsvApiV1ImportsTicktickParsePostResponseError;

export const getParseTicktickCsvApiV1ImportsTicktickParsePostUrl = () => {
  return `/api/v1/imports/ticktick/parse`;
};

export const parseTicktickCsvApiV1ImportsTicktickParsePost = async (
  parseTicktickCsvApiV1ImportsTicktickParsePostBody: string,
  options?: RequestInit
): Promise<parseTicktickCsvApiV1ImportsTicktickParsePostResponse> => {
  return apiMutator<parseTicktickCsvApiV1ImportsTicktickParsePostResponse>(
    getParseTicktickCsvApiV1ImportsTicktickParsePostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "text/plain", ...options?.headers },
      body: parseTicktickCsvApiV1ImportsTicktickParsePostBody,
    }
  );
};

export const getParseTicktickCsvApiV1ImportsTicktickParsePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof parseTicktickCsvApiV1ImportsTicktickParsePost>>,
    TError,
    { data: BodyType<string> },
    TContext
  >;
  request?: SecondParameter<typeof apiMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof parseTicktickCsvApiV1ImportsTicktickParsePost>>,
  TError,
  { data: BodyType<string> },
  TContext
> => {
  const mutationKey = ["parseTicktickCsvApiV1ImportsTicktickParsePost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof parseTicktickCsvApiV1ImportsTicktickParsePost>>,
    { data: BodyType<string> }
  > = (props) => {
    const { data } = props ?? {};

    return parseTicktickCsvApiV1ImportsTicktickParsePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ParseTicktickCsvApiV1ImportsTicktickParsePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof parseTicktickCsvApiV1ImportsTicktickParsePost>>
>;
export type ParseTicktickCsvApiV1ImportsTicktickParsePostMutationBody = BodyType<string>;
export type ParseTicktickCsvApiV1ImportsTicktickParsePostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Parse Ticktick Csv
 */
export const useParseTicktickCsvApiV1ImportsTicktickParsePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof parseTicktickCsvApiV1ImportsTicktickParsePost>>,
      TError,
      { data: BodyType<string> },
      TContext
    >;
    request?: SecondParameter<typeof apiMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof parseTicktickCsvApiV1ImportsTicktickParsePost>>,
  TError,
  { data: BodyType<string> },
  TContext
> => {
  return useMutation(
    getParseTicktickCsvApiV1ImportsTicktickParsePostMutationOptions(options),
    queryClient
  );
};
/**
 * Import tasks from a TickTick CSV export into a project.

The column_mapping maps TickTick column names to task_status_id values
in the target project.
 * @summary Import From Ticktick
 */
export type importFromTicktickApiV1ImportsTicktickPostResponse200 = {
  data: ImportResult;
  status: 200;
};

export type importFromTicktickApiV1ImportsTicktickPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type importFromTicktickApiV1ImportsTicktickPostResponseSuccess =
  importFromTicktickApiV1ImportsTicktickPostResponse200 & {
    headers: Headers;
  };
export type importFromTicktickApiV1ImportsTicktickPostResponseError =
  importFromTicktickApiV1ImportsTicktickPostResponse422 & {
    headers: Headers;
  };

export type importFromTicktickApiV1ImportsTicktickPostResponse =
  | importFromTicktickApiV1ImportsTicktickPostResponseSuccess
  | importFromTicktickApiV1ImportsTicktickPostResponseError;

export const getImportFromTicktickApiV1ImportsTicktickPostUrl = () => {
  return `/api/v1/imports/ticktick`;
};

export const importFromTicktickApiV1ImportsTicktickPost = async (
  tickTickImportRequest: TickTickImportRequest,
  headers?: ImportFromTicktickApiV1ImportsTicktickPostHeaders,
  options?: RequestInit
): Promise<importFromTicktickApiV1ImportsTicktickPostResponse> => {
  return apiMutator<importFromTicktickApiV1ImportsTicktickPostResponse>(
    getImportFromTicktickApiV1ImportsTicktickPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...headers, ...options?.headers },
      body: JSON.stringify(tickTickImportRequest),
    }
  );
};

export const getImportFromTicktickApiV1ImportsTicktickPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importFromTicktickApiV1ImportsTicktickPost>>,
    TError,
    {
      data: BodyType<TickTickImportRequest>;
      headers?: ImportFromTicktickApiV1ImportsTicktickPostHeaders;
    },
    TContext
  >;
  request?: SecondParameter<typeof apiMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof importFromTicktickApiV1ImportsTicktickPost>>,
  TError,
  {
    data: BodyType<TickTickImportRequest>;
    headers?: ImportFromTicktickApiV1ImportsTicktickPostHeaders;
  },
  TContext
> => {
  const mutationKey = ["importFromTicktickApiV1ImportsTicktickPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importFromTicktickApiV1ImportsTicktickPost>>,
    {
      data: BodyType<TickTickImportRequest>;
      headers?: ImportFromTicktickApiV1ImportsTicktickPostHeaders;
    }
  > = (props) => {
    const { data, headers } = props ?? {};

    return importFromTicktickApiV1ImportsTicktickPost(data, headers, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportFromTicktickApiV1ImportsTicktickPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importFromTicktickApiV1ImportsTicktickPost>>
>;
export type ImportFromTicktickApiV1ImportsTicktickPostMutationBody =
  BodyType<TickTickImportRequest>;
export type ImportFromTicktickApiV1ImportsTicktickPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Import From Ticktick
 */
export const useImportFromTicktickApiV1ImportsTicktickPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importFromTicktickApiV1ImportsTicktickPost>>,
      TError,
      {
        data: BodyType<TickTickImportRequest>;
        headers?: ImportFromTicktickApiV1ImportsTicktickPostHeaders;
      },
      TContext
    >;
    request?: SecondParameter<typeof apiMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importFromTicktickApiV1ImportsTicktickPost>>,
  TError,
  {
    data: BodyType<TickTickImportRequest>;
    headers?: ImportFromTicktickApiV1ImportsTicktickPostHeaders;
  },
  TContext
> => {
  return useMutation(
    getImportFromTicktickApiV1ImportsTicktickPostMutationOptions(options),
    queryClient
  );
};
